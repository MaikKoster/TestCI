function New-CMInstance {
    <#
    .SYNOPSIS
        Creates a new ConfigMgr object.

    .DESCRIPTION
        Creates a new ConfigMgr object.

    .EXAMPLE


    .NOTES

    #>
    [CmdletBinding(SupportsShouldProcess)]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute("PSUseDeclaredVarsMoreThanAssignments", "")]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute("PSAvoidGlobalVars", "")]
    PARAM (
        # Specifies the ConfigMgr WMI provider Class Name
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [string]$ClassName,

        # Specifies the properties to be supplied to the new object
        [Parameter(Mandatory)]
        [ValidateNotNullOrEmpty()]
        [hashtable]$Property,

        # Set EnforceWMI to enforce the deprecated WMI cmdlets
        # still required for e.g. embedded classes without key as they need to be handled differently
        #[switch]$EnforceWMI,

        # Specifies if the new instance shall be created on the client only.
        # Will be used for embedded classes without key property
        [switch]$ClientOnly
    )

    Process {
        # Ensure ConfigMgr Provider information is available
        If (Test-CMConnection) {
            $PropertyString = ($Property.GetEnumerator() | ForEach-Object { "$($_.Key)=$($_.Value)" }) -join "; "
            Write-Debug "Create new $ClassName object. Properties: $PropertyString"

            # TODO: Still required?
            # If ($EnforceWMI) {
            #     $NewCMObject = New-CMWMIInstance -ClassName $ClassName

            #     If ($null -ne $NewCMObject) {
            #         #try to update supplied arguments
            #         Try {
            #             Write-Debug "Add properties to WMI class"
            #             $Property.GetEnumerator() | ForEach-Object {
            #                 $Key = $_.Key
            #                 $Value = $_.Value
            #                 Write-Debug "$Key : $Value"
            #                 $NewCMObject[$Key] = $Value
            #             }
            #         } Catch {
            #             Write-Error "Unable to update properties on WMI class $ClassName"
            #         }
            #     }
            # } Else {
                $Params = @{
                    Namespace = $Global:CMNamespace
                    ClassName = $ClassName
                    Property = $Property
                    ErrorAction = "Stop"
                }

                If ($ClientOnly.IsPresent) {
                    $Params.ClientOnly = $true
                } Else {
                    $Params.CimSession = $global:CMSession
                }

                If ($PSCmdlet.ShouldProcess("Class: $ClassName", "Call New-CimInstance")) {
                    $NewCMObject = Invoke-CimCommand { New-CimInstance @Params}

                    If ($null -ne $NewCMObject) {
                        # Ensure that properties generated by the WMI provider are udpated
                        $hack = $NewCMObject.PSBase | Select-Object * | Out-Null
                    }
                }
            # }

            Return $NewCMObject
        }
    }
}